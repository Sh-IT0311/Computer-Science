# 자료구조 및 알고리즘
Q.HashMap
<br>A.
* hash function
    * 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수
        * 임의의 길이의 데이터를 key라고 함
        * 반환된 고정된 길이의 데이터를 hash value라고 함
        * key를 hash value로 매핑하는 과정을 hashing이라고 함
        * 특징
            * 항상 고정된 길이의 해시값을 반환
            * 입력 값이 아주 조금만 변경되어도 전혀 다른 해시 값이 반환됨
            * 해시값으로 키를 유추할 수 없음
        * 대표 알고리즘
            * MD5
            * SHA
* hash collision
    * 서로 다른 두 개의 키가 같은 해시 값을 가지는 경우를 해시충돌이라고 함
    * 해시 함수가 무한한 입력값을 받아 해시값을 도출해내는 경우, 해시 충돌은 항상 존재함
* hash table(= hash map, dictionary)
    * 해시함수를 통해 키를 해시값으로 매핑하고, 이 해시값을 index 또는 주소로 삼아 value를 저장하는 자료구조
    * 데이터가 저장되는 곳을 bucket 또는 slot이라고 함
    * 해시충돌이 일어났을 경우..
        * open addressing
            * 이동폭에 따라 해시값을 바꿔가며 다른 해시 버킷에 해당 value를 삽입하는 방식
            * 종류
                * Linear Probing(선형조사)
                    * 최초 해시값에 해당하는 버킷에 다른 데이터가 저장되어 있다면, 해시값을 1칸씩 옮기면서 데이터가 없는 버킷을 찾음
                    * 주변 버킷이 모두 채워져 있는 Primary Clustering 문제에 취약함
                * Quadratic Probing(제곱조사)
                    * 최초 해시값에 해당하는 버킷에 다른 데이터가 저장되어 있다면, 해시값을 이동폭의 제곱(1,4,9...)만큼 옮기면서 데이터가 없는 버킷을 찾음
                    * 여러 개의 다른 키들이 모두 동일한 초기 해시값을 갖고 있는 Secondary Clustering에 취약함
                * double hashing
                    * 2개의 해시함수를 준비해서 최초의 해시값을 얻을 때, 또 하나는 해시충돌이 일어났을 때 이동폭을 얻기 위해 사용함
        * separable chaining
            * bucket의 type을 linked list 또는 Tree를 사용하여 해시 충돌이 일어나면, 해시값에 해당하는 버킷에 value를 추가하는 방식
* hash bucket resizing(open addressing 방식에 해당하는 것 같음)
    * 메모리 사용을 아끼기 위해 초기 해시 버킷의 개수를 적게 잡고, 현재 key-value 쌍 개수가 지정된 해시 버킷의 개수의 일정 비율 만큼의 개수(임계점)을 넘어서면 해시 버킷의 개수를 두배로 늘림
        * 여기서 임계점은 해시 버킷의 일정 비율을 결정하는 load_factor(ex> 0.75)라는 파라미터로 결정됨

<br>Q. quick sort
<br>A.
* 배열 내에 존재하는 값들과 비교하기 위한 pivot 개념을 도입해, 이 pivot을 기준으로 좌측은 pivot보다 작은 값들을 위치시키고, 우측은 pivot보다 큰 값들이 위치하도록 함. 그리고 pivot을 제외한 왼쪽 부분 배열과 오른쪽 부분 배열에 똑같은 과정을 부분 배열의 크기가 0 또는 1이 될 때까지 반복하여 정렬된 리스트를 얻는 정렬 방법임.
* 장점으로는 추가적인 메모리 공간을 요구하지 않지만, 단점으로는 불균형 분할을 일으키는 pivot을 선정할 경우 수행시간이 오래 걸리게 됨

<br>Q. merge sort
<br>A.
* 더이상 나누어지지 않을 때까지 반 씩 분할하다가 더 이상 나누어지지 않는 경우 역으로 결합의 과정을 거치는데, 분할 된 부분 배열들끼리 비교를 통해 정렬된 채로 결합을 이루는 과정을 반복 진행하여 최종적으로 정렬된 리스트를 얻게 되는 정렬 방법임.
* 장점으로는 데이터의 분포에 영향을 덜 받아 시간복잡도가 크게 달라지지 않지만, 단점으로는 배열의 크기가 큰 경우에는 데이터의 이동 횟수가 많아져서 매우 큰 시간적 낭비를 초래할 수 있음

<br>Q. heap
<br>A.
* 루트 노드가 항상 최댓값 또는 최솟값을 가지고 있고, 부모 노드가 자식 노드보다 큰(작은) 완전 이진 트리임
    * 최대힙 또는 최소힙에 따라 해석을 달리함
        * 루트노드가 항상 큰 값 / 작은 값
        * 부모노드보다 자식노드가 크다 / 작다
    * left child node가 right child node 보다 크다/작다 이런 개념은 없고 부모 노드가 자식 노드보다 크기(작기)만 하면 됨
* 삽입의 경우 비어있는 트리의 마지막 자리에 위치시킨 후 부모 노드와 비교하면서 위치를 찾아감
* 삭제의 경우 루트 노드를 제거하고 그 자리에 트리의 마지막 자리 노드를 배치하고, 이 노드를 자식 노드들과 비교하여 위치를 찾아감
    * 자식 노드 두 개 모두 조건을 만족하는 경우 자식 노드 중 큰 값(작은 값)을 선택함
