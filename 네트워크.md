# 네트워크

Q. OSI 7계층? TCP/IP 계층?
<br>A. OSI 7계층은 국제표준기구 ISO가 발표한 네트워크 모델입니다. 각 계층을 기능을 간단하게 브리핑 하자면,
1. physical layer : 디지털 신호와 전기 신호를 변환
2. data link layer : 동일한 네트워크에서 데이터를 전송
3. network layer : 서로 다른 네트워크에서 데이터를 전송
4. transport layer : 세그멘테이션, 흐름제어, 오류제어, 혼잡제어 기능 제공(-> TCP)
5. session layer : 세션을 열고 닫음, 세션 복구 기능을 제공
6. presentation layer : 데이터의 변환, 압축, 암호화 기능을 제공
7. application layer : 응용 프로세스를  직접 사용하여 직접적인 응용 서비스를 제공

* 현재는 TCP/IP 계층이 시장 점유율에 우위를 점하고 있는데, application layer = application layer + presentation layer + session layer 구조를 취하고 있습니다.

<br>Q. TCP(Transmission Control Protocol) / UDP(User Datagram Protocol)?
<br>A. TCP는 신뢰성 있는 데이터 통신을 가능하게 해주는 연결형 프로토콜로, 3-way handshaking / 4-way handshaking을 통해 연결을 설정 및 해제하는 과정을 포함하고 있고, 데이터의 순서 보장, 흐름 제어, 혼잡 제어, 오류 제어, 세그멘테션 등을 제공 하고 있습니다.

<br>

그에 반해, UDP는 TCP보다 신뢰성은 떨어지지만 속도가 일반적으로 빠른 비연결형 프로토콜로, 오류를 감지하는 정도의 기능만 제공되고, TCP와 비교해서 세그멘테이션을 하지 않기 때문에 이러한 부분은 application 계층에서 진행이 이루어져야 합니다.

<br>

* 세그멘테이션 : 세그먼트 단위로 나누는 것

* 혼잡제어 : 네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지

* 흐름제어 : 송수신간에 데이터 처리 속도 차이를 고려하는 것으로, 수신자의 버퍼 오버플로우 문제를 방지

* 오류제어 : TCP header - check sum <- 체크섬 계산 알고리즘으로 생성하여 송신측 Header에 삽입, 수신측에서 동일한 알고리즘으로 체크섬을 계산하고 Header에 있는 체크섬과 비교해서 오류를 감지함, 오류가 있을 경우 해당 데이터를 재전송하는 방식으로 오류를 해결함

* 3-way handshaking(연결 설정)
    1. SYN
    2. SYN + ACK
    3. ACK
* (TCP) 데이터 전송방식
    1. packet
    2. ACK
* 4-way handshaking(연결 해제)
    1. FIN
    2. ACK
    3. (TIME_WAIT) 남은 Packet
    4. FIN
    5. ACK

* (UDP) 데이터 전송방식
    1. packet
    
<br>Q. Web Socket?
<br>A. 웹소켓이란 두 프로그램 간에 메시지를 교환하기 위한 통신 방법 중에 하나로 통상적인 HTTP 통신은 클라이언트가 요청을 보내는 경우에만 서버가 응답하는 단방향 통신인 것과 달리 웹소켓은 양방향 통신과 실시간 네트워킹을 가지는 특징을 가지고 있습니다. 또한 연결수립 과정은 HTTP 통신을 통해 이루어지며 연결 해제는 close 프레임을 주고 받으며 연결을 종료하게 됩니다.

<br>Q. 웹서버에서 정보를 가져오는 과정?
<br>A.
1. 웹브라우저에 URL을 입력 후 엔터
    1. 먼저 도메인을 IP주소로 변경하기 위해 DNS 서버와 통신을 함
    2. 기본적으로 TCP를 사용했을 것이기 때문에, 3-way handshaking 과정이 발생함
2. HTTP request  메시지가 생성되고, 계층별로 header가 붙는 캡슐화 과정을 거쳐서 LAN 케이블을 통해 송출됨
3. 출발지 스위치에서 MAC 주소(모르면, ARP를 통해 찾음)를 통해 출발지 라우터로 패킷을 전달하고, IP 주소를 확인하면서 라우팅 알고리즘과 라우팅 테이블을 활용해 각각의 라우터를 거쳐서 목적지 라우터에 도착함
    1. 만약 프록시 서버가 설정되어 있다면, 이를 거쳐 웹서버까지 통신할 수 있음 (프록시 서버가 문제를 해결하는 경우, 웹서버와의 통신은 발생하지 않음)
    2. 출발지 라우터, 목적지 라우터에서 사설 IP와 공인 IP 간에 변경이 이루어짐
4. 목적지 라우터는 MAC 주소를 활용해 목적지 스위치로 패킷을 전달하고, 목적지 스위치에서 ARP 프로토콜로 목적지 IP 주소를 통해 MAC 주소를 알아내고 웹서버에 도착하게 됨
5. 80번 포트(HTTP의 기본 포트)를 사용하고 있는 애플리케이션에 데이터가 전달되고, HTML을 응답해줌
6. 응답은 방금과정의 역순으로 일어남
7. 연결 종료시 4-way handshaking이 일어남

<br>Q. 대칭키? 공개키(비대칭키)?
<br>A.
* 대칭키 : 동일한 키(-> 대칭키)로 암호화 / 복호화를 수행합니다. 즉, 송수신측에서 동일한 키를 사용한다는 의미인데, 이러한 동일한 키가 해킹에 의해 노출 되면 데이터가 노출되는 단점이 있지만, 기술 구현이 간단하는 장점을 가지고 있습니다.

* 공개키 : 서로 다른 키(-> 비대칭키라고 불리는 이유, 공개키 / 개인키)로 암호화 / 복호화를 수행합니다. 구체적으로, 송신측은 공개되어 있는 키, 즉 공개키로 암호화를 진행하여 송신을 하고 수신측은 개인만 소유하고 있는 개인키를 통해 복호화를 진행하는 것입니다. 장단점으로는, 복호화를 할 수 있는 개인키는 개인만 소유하고 있기 때문에 보안에는 우수하지만, 기술 구현에 대한 비용이 크다는 단점이 있습니다.

<br>Q. HTTP? HTTPS?
<br>A.
* HTTP는 웹서버와 브라우저간에 통신을 주고받게하는 기본적인 프로토콜입니다. 이러한 HTTP에는 송신하는 데이터에 대한 암호화를 지원하지 않는데, 이러한 문제를 보완한 것이 HTTPS로, HTTP에 서버와 브라우저간에 암호화된 연결을 도와주는 SSL(Secure sockets layer)을 사용하였습니다. SSL은 application layer와 transport layer 사이에 속한 독립적인 프로토콜 계층으로, HTTP 뿐만 아니라 FTP, SMTP 등에도 적용 가능합니다. 주의할 점은, HTTP의 body만 암호화 하는 것이고, HTTP Header는 암호화를 하지 않습니다. 여기서 SSL은 공개키와 대칭키의 혼합방식을 사용하는데, 공개키로 송/수신측이 대칭키를 공유하고 이러한 대칭키로 송/수신측이 암호화 / 복호화 진행하는 것입니다.


<br>Q. forward proxy 서버? reverse proxy 서버?
<br>A. proxy 서버는 클라이언트와 서버간에 중계 서버로, 통신을 대리 수행하는 서버입니다.
* forward proxy 서버는 서버보단 클라이언트 측면에 놓여있는 프록시 서버로, 클라이언트가 요청한 내용을 캐싱 하기 때문에 똑같은 요청이 들어오면 웹서버까지 통신을 진행하지 않고 바로 응답을 해줄 수 있습니다. 또한 웹서버 입장에서 요청 받은 IP주소는 프록시 서버 IP로 뜨기 때문에 클라이언트의 정체를 감출 수 있는데, 이러한 것을 익명성이라고 하며, 포워드 프록시 서버는 익명성을 제공합니다.

* reverse proxy 서버는 클라이언트보단 서버 측면에 놓여있는 프록시 서버입니다. 클라이언트가 요청한 내용을 캐싱 하기 때문에 똑같은 요청이 들어오면 웹서버까지 통신을 진행하지 않고 바로 응답을 해줄 수 있습니다. 또한 실제 서버의 IP 주소를 노출시키지 않기 때문에 서버 정보를 클라이언트로부터 숨길 수 있는 보안에 좋습니다. 그리고 마지막으로 load balancing에 사용되기 때문에, 서버의 과부화를 막을 수 있습니다.

<br>Q. Load balancer?
<br>A. 여러 대의 서버가 분산 처리 할 수 있도록 요청을 나누어 주는 장치 또는 기술을 통칭합니다. 컴퓨터의 스펙을 향상시키는 것에 한계가 있기 때문에, 서버를 증설하고 이러한 여러 대의 서버로 분산 처리 할 수 있도록 로드밸런싱을 하는 것입니다.

<br>Q. ARP?
<br>A. 네트워크 상에서 IP주소(논리주소)를 MAC주소(물리주소)로 대응시키기 위해 사용되는 프로토콜로, 목적지의 IP주소를 알고 있는 상황에서 목적지의 MAC주소를 알아내기 위해 사용되는 기술입니다. 목적지의 MAC주소를 모르기 때문에 ARP 요청은 브로드캐스팅으로 이루어지며, ARP 응답은 유니캐스트로 이루어집니다.

* +) ARP 요청 메시지 (송신자 MAC(물리)주소, 송신자 IP주소, 00-00-00-00-00, 수신자 IP주소)

<br>Q. 쿠키? 세션?
<br>A. 쿠키는 서버가 사용자의 웹 브라우저에 전송하는 작은 데이터 조각으로 서버가 클라이언트를 식별 할 수 있도록 해주는 기술로, 개인설정 유지, 사용자 트래킹, 세션관리 등을 위해 사용됩니다. HTTP 특성 중 무상태성(Stateless)이 있는데, 즉 서버가 클라이언트를 식별할 수 있는 방법을 제공하지 않기 때문에 쿠키를 통해 서버가 클라이언트를 식별 할 수 있도록 하는 것입니다. 쿠키는 클라이언트가 서버에 처음 요청 할 때 응답으로 받게 되며, 해당 서버와 통신을 할 때 쿠키를 무조건 포함하여 요청을 하게 됩니다.

<p>
세션은 일정 시간동안 클라이언트와 웹서버 간에 계속 연결을 유지시켜는 기술로, 쿠키를 이용해 구현된 기술입니다. 세션에 대한 정보는 서버측에 저장해놓고 클라이언트에게 세션 쿠키를 주어 서버가 클라이언트를 식별할 수 있도록 하는 방식입니다.

<br>

* 지속쿠키 : 디스크에 저장되어 계속 남아있는 쿠키로, 개인 설정 유지 등에 활용됨
* 세션쿠기 : 브라우저를 닫는 순간 삭제되는 쿠키로, 세션을 관리하는데 활용됨

<br>Q. DNS? - Domain Name System
<br>A. 도메인 네임을 컴퓨터가 처리할 수 있는 IP주소로 변환해주는 시스템 입니다. 우리는 통신사로부터 인터넷 접속을 할 수 있도록 서비스를 공급받는데, 여기서 Local DNS 서버의 IP 주소도 공급 받습니다. 그래서 도메인 네임을 IP주소 변환하고자 할 때 클라이언트는 먼저 Local DNS 서버에 질의를 보내며, 질의 받은 도메인의 IP주소를 모르는 경우 Local DNS 서버가 계층으로 이루어진 네임 서버들에게 재귀적 또는 반복적인 질의를 요청하여 IP주소를 알아내고 Local DNS서버를 다시 거쳐 클라이언트에게 IP주소를 알려주게 됩니다.

* 질의 방식이 2가지 : 재귀적, 반복적

<br>Q. 사설IP? 공인IP?
<br>A.
* 사설IP는 라우터를 통해 할당 받아 내부 네트워크 안에서 사용하는 가상의 주소로, 별도의 설정 없이는  외부 인터넷 상에서는 사용할 수 없는 IP입니다.
* 공인IP는 전 세계에서 유일한 주소로, 보통 인터넷 서비스 공급자에 의해 제공 받고 외부 인터넷 네트워크에서 사용할 수 있습니다.

<br>Q. NAT? 포트포워딩?- NAT : Network Address Translation
<br>A. 사설IP와 공인IP를 서로 변환 해주는 기술로 사설IP + 포트번호와 공인IP + 포트번호 간에 변환이 이루어집니다. 하지만 둘의 차이점은 포트번호의 설정 차이입니다. 포트포워딩은 사용자가 직접 설정하는 반면에, NAT은 라우터를 통해 이루어지는데, 라우터에서 임의로 지정한다는 차이가 있습니다.